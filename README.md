**Start the project using:**

```bash
docker compose up
```

**To run the tests, use the following command:**

```bash
docker exec -it 51e6c48cab6ab5808dfabcb5 bundle exec rspec
```

**To clear all data use the following endpoint:**
```http
POST localhost:8080/v1/api/flush
```


**Short explanation**

Швидкість вираховуємо наступним чином, якщо корабель відправив координати і це його перші дані в системі, ми вважаємо що він стоїть на місці і його швидкість `0` відповідно.

Коли відправляються наступні координати ми зрівнюємо їх з попередніми, тобто вираховуємо яку відстань корабель пройшов за проміжок часу між поточними координатами і попередніми.

У 18:00:00, це `1713625200` в `UNIX timestamp` `Ship_A` відправляє свої координати:
```json
{
  "time": 1713625200,
  "x": 100,
  "y": 100
}
```

Так як це перші координати корабля в системі, ми припускаємо що він стоїть на місці і його швидкість 0.

Через 5 секунд, Ship_A відправляє інші координати:

```json
{
	time: 1713625205,
	x: 105,
	y: 100
}
```

З цих даних ми робимо висновок що корабель рухається лише по осі X, і за 5 секунд він пройшов 5 клітинок, тобто його швидкість 1 клітинка на секунду.

Детальна формула як ми рахуємо швидкість:

```ruby
start_x, start_y = 100, 100  
finish_x, finish_y = 105, 100

first_point_time = 1713625200
last_point_time = 1713625205

time_diff = last_point_time - first_point_time

dx = finish_x - start_x  
dy = finish_y - start_y

speed_x = (dx.to_f / time_diff).round # 1
speed_y = (dy.to_f / time_diff).round # 0
common_speed = (Math.sqrt((dx**2 + dy**2)) / time_diff).round
```

Так як ми знаємо що швидкість 1 клітинка за секунду, можемо визначити координати для кожної секунди з наступних 60-ти.

Наприклад через 10 секунд Ship_A буде мати координати:

```ruby
time_diff + 10
future_x = finish_x + speed_x * 10 # 105 + (1 * 10) = 115
future_y = finish_y + speed_y * 10 # 100 + (1 * 0) = 100
```

Для збереження тимчасових даних про траєкторію використовується Redis, в даному випадку структура Set. В ключі ми вказуємо координату, та timestamp коли ця координата буде занята цим кораблем.

Так як по умовах задачі нам потрібно розрахувати траєкторію на найближчі 60 секунд і найбільша швидкість корабля може становити 100 клітинок в секунду. Ми знаємо що за одну ітерацію корабель не може пройти більше 6000 клітинок. Тому додатково кожну координату ми ділимо на 6000 для того щоб сформувати уявну межу поля, і не шукати кораблі за його межами, які при таких параметрах всеодно не входять до траєкторії.

```ruby
x = 105 / 6000 = 0.0175 = 0
y = 100 / 6000 = 0.0166 = 0

grid_x = 0
grid_y = 0
```

Уявімо що якийсь корабель має координати x: 7453, y: 5600. Ми б тоді не брали його координати до уваги, так як він знаходиться в іншому квадраті.

```ruby
x = 7453 / 6000 = 1.242 = 1
y = 5600 / 6000 = 0.9333 = 0

grid_x = 1
grid_y = 0
```

Ключ для цих координат буде мати вигляд:

```ruby
future:<grid_x>:<grid_y>:<timestamp>
```

В значення ми записуємо id корабля, та його координати

```ruby
{
	ship_id: '867ac426-aed6-4c1d-81ce-375f3c70c243',
	x: 115,
	y: 100,
	version: 1713625205
}
```

Ставимо TTL для цього ключа 70 секунд.

Якщо при розрахунку траєкторії для іншого корабля ми аналогічним чином формуємо ключ, і перевіряємо чи є такий в redis. Якщо ключ є, дістаємо данні по кораблю і його координатах. Якщо x та y збігаються, тобто ми дізнаємось що в цю саму секунду в цих самих координатах буде інший корабль з певним id, ми ще додатково перевіримо версію запису. Якщо версія актуальна, значить є небезпека, далі по точках рахуємо тільки який рівень, якщо версія не актуальна, ігноруємо ці координати і вважаємо що небезпеки саме по цих точках нема.

**Як визначається актуальність версії**

Коли корабель відправляє свої координати і час, ми записуємо в структуру **STRING**  з ключем `ship:ship_id` час який корабель відправив з координатами.

```redis
SET ship:867ac426-aed6-4c1d-81ce-375f3c70c243 1713625205 
```

Це потрібно для випадків коли корабель після відправки координат отримав статус **RED** і в межах 70-ти секунд відправляє інші, підкореговані координати. Так як TTL в сеті з траєкторією 70 секунд, то виходить що попередні координати вже не валідні, тому цей маршрут не треба враховувати. Тоді коли корабель бачить що певні координати в певний момент часу зайняті, він бере ship_id та version і робить вибірку для цього корабля, і порівнює версії.

В нашому прикладі:

```ruby
ship_id = '867ac426-aed6-4c1d-81ce-375f3c70c243'
version = 1713625205
```

Тому ми робимо вибірку

```redis
SMEMBERS ship:867ac426-aed6-4c1d-81ce-375f3c70c243
```

Отримуємо 1713625205 що і дорівнює нашому значенню в версії траєкторії.



**Випадок коли ми припускаємо що корабель не рухається**

Коли корабель відправляє свої координати, ми їх записуємо в redis set з ключем у форматі

```ruby
positions:<x>:<y>
```

```redis
SET ship:100:100 867ac426-aed6-4c1d-81ce-375f3c70c243
```

В якості значення вказуємо ship_id, і зберігаємо це без TTL до того часу коли корабель не відправить нові координати.

Коли отримуємо нові координати, видаляємо попередні, так як в нас є координати попередньої позиції, і знову зберігаємо в set, але вже з новими координатами.

Також коли вираховуємо траєкторію, також дивимось в цей set, щоб дізнатись чи не знаходиться там якийсь інший корабель.

**Відстань між точками рахується наступним чином:**

```
dx = point_a_x - point_b_x
dy = point_a_y - point_b_y

max(dx, dy) - 1
```
